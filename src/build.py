import config
import luau
import treecode
import toml
import os
from typing import TypedDict, Literal, Union, Any

DEFAULT_ROJO_PROJECT_PATH = "default.project.json"
MAID_WALLY_PATH = "nightcycle/maid@1.1.4"
MIDAS_WALLY_PATH = "nightcycle/midas@2.0.0"

FOREMAN_DEFAULT_PATH = "foreman.toml"
AFTMAN_DEFAULT_PATH = "aftman.toml"

GENERATED_HEADER_WARNING_COMMENT = "-- this script was generated by midas-clt, do not manually edit"

def get_tool(source: str, version: str) -> str:
	alt_nickname = source.split("/")[len(source.split("/"))-1]
	if os.path.exists(FOREMAN_DEFAULT_PATH):
		foreman_config = toml.loads(open(FOREMAN_DEFAULT_PATH, "r").read())
		foreman_tools = foreman_config["tools"]
		for nickname, entry in foreman_tools.items():
			if nickname == alt_nickname:
				alt_nickname = "midas_"+alt_nickname

			if "source" in entry and "version" in entry:
				if entry["source"] == source and entry["version"] == version:
					return nickname

		foreman_tools[alt_nickname] = {
			"source": source,
			"version": version
		}

		foreman_file = open(FOREMAN_DEFAULT_PATH, "w")
		foreman_file.write(toml.dumps(foreman_config))
		foreman_file.close()

		os.system("foreman install")

		return alt_nickname

	elif os.path.exists(AFTMAN_DEFAULT_PATH):
		aftman_config = toml.loads(open(AFTMAN_DEFAULT_PATH, "r").read())
		aftman_tools = aftman_config["tools"]
		aft_path = source+"@"+version
		for nickname, path in aftman_tools.items():
			if nickname == alt_nickname:
				alt_nickname = "midas_"+alt_nickname
			if path == aft_path:
				return path
		
		os.system(f"aftman add {aft_path} -{alt_nickname}")
		return alt_nickname
	else:
		raise IndexError("no foreman or aftman config files found")

def update_wally():

	project_path = get_rojo_path()

	wally_tool_name = get_tool("UpliftGames/wally", "0.3.1")
	rojo_tool_name = get_tool("rojo-rbx/rojo", "7.1.0")
	wpt_tool_name = get_tool("wally-package-types", "1.2.0")
	os.system(f"{wally_tool_name} install")
	os.system(f"{rojo_tool_name} sourcemap {project_path} --output sourcemap.json")	
	os.system(f"{wpt_tool_name} --sourcemap sourcemap.json Packages")


def get_wally_package_nickname(package_wally_path: str) -> str:
	wally_config = toml.loads(open("wally.toml", "r").read())
	generated_nickname = (package_wally_path.split("/")[1].split("@")[0]).title()
	for nickname, package_path in wally_config["dependencies"].items():
		if nickname == generated_nickname:
			generated_nickname = "Midas"+generated_nickname.title()
		if package_wally_path == package_path:
			return nickname

	# no maid installed
	wally_config["dependencies"][generated_nickname] = package_wally_path

	open("wally.toml", "w").write(toml.dumps(wally_config))
	update_wally()

	return generated_nickname

def run_stylua(path: str):
	stylua_tool_name = get_tool("JohnnyMorganz/StyLua", "0.15.3")
	os.system(f"{stylua_tool_name} {path}")

def import_type(module_variable_name: str, type_name: str, type_local_name="") -> str:
	if type_local_name == "":
		type_local_name = type_name

	return f"type {type_local_name} = {module_variable_name}.{type_name}"	

def require_roblox_wally_package(package_wally_path: str) -> str:

	package_nickname = get_wally_package_nickname(package_wally_path)

	midas_config = config.get_midas_config()
	package_path = ""
	roblox_path_keys = (midas_config["build"]["roblox_wally_package_folder_path"]+"/"+package_nickname).split("/")
	for i, key in enumerate(roblox_path_keys):
		if i == 0:
			package_path += key
		else:
			package_path += f":WaitForChild(\"{key}\")"

	package_path = package_path.replace("game:WaitForChild(\"ReplicatedStorage\")", "game:GetService(\"ReplicatedStorage\")")

	return f"local {package_nickname} = require({package_path})"

def get_rojo_path() -> str:
	if os.path.exists(DEFAULT_ROJO_PROJECT_PATH):
		return DEFAULT_ROJO_PROJECT_PATH
	for file_path in os.listdir(""):
		if os.path.isfile(file_path):
			base, ext = os.path.splitext(file_path)
			if ext == ".json":
				sec_base, sec_ext = os.path.splitext(base)
				if sec_ext== ".project":
					return file_path


def get_if_using_lua_or_luau_ext(build_path: str) -> str:
	base, lua_ext = os.path.splitext(build_path)
	return lua_ext[1:]

def get_domain_ext(build_path: str) -> str | None:
	base, lua_ext = os.path.splitext(build_path)
	second_base, domain_ext = os.path.splitext(base)
	if len(domain_ext) == 0:
		return None
	else:
		return domain_ext[1:]

def get_if_module_script(build_path: str) -> bool:
	if get_domain_ext(build_path) == None:
		return True
	else:
		return False

def build_python_script():
	print("build_python_script")

def build_shared_luau_tree():
	print("build_shared_luau_tree")	

def build_client_boot():
	print("build_client_boot")	

def build_server_boot():
	print("build_server_boot")
	auth_config = config.get_auth_config()
	midas_config = config.get_midas_config()
	encoding_config = treecode.get_tree_encoding()

	build_path = midas_config["build"]["server_boot_script_path"]
	title_id = auth_config["playfab"]["title_id"]
	dev_secret_key = auth_config["playfab"]["dev_secret_key"]

	config_table = {
		"Version": {
			"Major": midas_config["version"]["major"],
			"Minor": midas_config["version"]["minor"],
			"Patch": midas_config["version"]["patch"],
		},
		"Encoding": {
			"Marker": encoding_config["marker"],
			"Dictionary": {
				"Properties": encoding_config["dictionary"]["properties"],
				"Values": encoding_config["dictionary"]["values"]
			},
			"Arrays": encoding_config["arrays"]
		},
		"SendDeltaState": False,
		"PrintLog": False,
		"SendDataToPlayFab": True,
		"Templates": {
			"Join": midas_config["templates"]["join"],
			"Chat": midas_config["templates"]["chat"],
			"Population": midas_config["templates"]["population"],
			"ServerPerformance": midas_config["templates"]["server_performance"],
			"Market": midas_config["templates"]["market"],
			"Exit": midas_config["templates"]["exit"],
			"Character": midas_config["templates"]["character"],
			"Player": midas_config["templates"]["player"],
			"Demographics": midas_config["templates"]["demographics"],
			"ClientPerformance": midas_config["templates"]["client_performance"],
			"Group": midas_config["templates"]["group"],
		},
	}

	if "hotfix" in midas_config["version"]:
		config_table["Version"]["hotfix"] = midas_config["version"]["hotfix"]
	
	maid_nickname = get_wally_package_nickname(MAID_WALLY_PATH)
	analytics_nickname = get_wally_package_nickname(MIDAS_WALLY_PATH)

	contents = [
		"--!strict",
		GENERATED_HEADER_WARNING_COMMENT,
		"\n-- packages",
		require_roblox_wally_package(MIDAS_WALLY_PATH),
		require_roblox_wally_package(MAID_WALLY_PATH),
		"\n"+import_type(maid_nickname, "Maid"),
	]

	config_text = f"-- configure package \n{analytics_nickname}:Configure({luau.dump_dict(config_table, indent_count=1, skip_initial_indent=True, add_comma_at_end=False, multi_line=True)})"
	init_text = f"-- initialize playfab http request variables \n{analytics_nickname}.init(\"{title_id}\", \"{dev_secret_key}\")"

	init_function_content = [
		f"\n\t{config_text}",
		f"\n\t{init_text}",
		f"\n\tmaid:GiveTask({analytics_nickname})",
		f"\n\treturn nil",
	]
	
	if get_if_module_script(build_path):
		script_name = build_path.split("/")[len(build_path.split("/"))-1]
		if get_if_using_lua_or_luau_ext(build_path) == "luau":
			script_name = script_name.replace(".luau", "")
		else:
			script_name = script_name.replace(".lua", "")

		contents += [
			"\nlocal "+script_name+" = {}"
			f"\n\nfunction {script_name}.init(maid: Maid): nil",
		] + init_function_content + [
			f"end"
			f"\nreturn {script_name}"
		]
	else:
		contents += [
			f"\nfunction init(maid: Maid): nil",
		] + init_function_content + [
			f"end",
			f"\nlocal maid = {maid_nickname}.new()",
			f"maid:GiveTask(script.Destroying:Connect(function() maid:Destroy() end))",
			f"init(maid)"
		]

	dir_name, file_name = os.path.split(build_path)
	if not os.path.exists(dir_name):
		os.makedirs(dir_name)
	elif os.path.exists(build_path):
		os.remove(build_path)

	out_file = open(build_path, "w")
	out_file.write("\n".join(contents))
	out_file.close()

	run_stylua(build_path)

def main():
	build_shared_luau_tree()
	build_python_script()
	build_client_boot()
	build_server_boot()